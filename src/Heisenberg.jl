#!usr/bin/env julia

################## Librairies ####################
using ITensors
using ITensorMPS
using LinearAlgebra
using ProgressMeter

################## Functions #####################

"""
N -- number of sites 
J -- coupling constant
h -- disorder constant

Define the operator expτ(-JSS - hSz)
"""
function ITensors.op(::OpName"expτSS", ::SiteType"S=1/2", s1::Index, s2::Index; τ, h)
    H =
        -1 / 2 * op("S+", s1) * op("S-", s2) +
        -1 / 2 * op("S-", s1) * op("S+", s2)
    -h * op("Sz", s1) * op("Sz", s2)
    return exp(τ * H)
end

"""
N -- number of sites 
J -- coupling constant
h -- disorder constant

return the Trotter Suzuki gates (order 2) and the Hamiltonian to compute TEBD and energy
"""
function gateTrotterSuzukiandhamiltonian(mps, h, δτ, parity::String)#essayer l'autre contraction où on fait pair impair à la suite au lieu de tout pair puis impair
    N = length(mps)
    s = siteinds(mps)
    if mod(N, 2) == 0
        if parity == "even"
            gates = ops([("expτSS", (n, n + 1), (τ=-δτ / 2, h=h,)) for n in 1:2:(N-1)], s)
        elseif parity == "odd"
            gates = ops([("expτSS", (n, n + 1), (τ=-δτ, h=h,)) for n in 2:2:(N-2)], s)
        end
    elseif mod(N, 2) == 1
        if parity == "even"
            gates = ops([("expτSS", (n, n + 1), (τ=-δτ / 2, h=h,)) for n in 2:2:(N-2)], s)
        elseif parity == "odd"
            gates = ops([("expτSS", (n, n + 1), (τ=-δτ, h=h,)) for n in 1:2:(N-1)], s)
        end
    end
    #@show typeof(gates)
    #append!(gates, reverse(gates))
    return gates
end

"""
return the vector of Trotter Suzuki gates in a row that means gates are in the order: (1,2) ; (2,3) ; ...
"""
function gateTrotterSuzukirow(mps, h, δτ)
    N = length(mps)
    s = siteinds(mps)
    gates = ops([("expτSS", (n, n + 1), (τ=-δτ / 2, h=h,)) for n in 1:1:(N-1)], s)
    return gates
end

"""
mps -- mps on which you compute the energy
h -- disorder

return the Heisenberg Hamiltonian with disorder with the ITensorMPS.MPO type 
"""
function hamiltonianHeisenberg(mps, h)
    N = length(mps)
    s = siteinds(mps)
    ampo = AutoMPO()
    for j in 1:N-1
        add!(ampo, -1 / 2, "S+", j, "S-", j + 1)
        add!(ampo, -1 / 2, "S-", j, "S+", j + 1)
        add!(ampo, -1 / 2, "Sz", j, "Sz", j + 1)
        add!(ampo, -h, "Sz", j)
    end
    add!(ampo, -h, "Sz", N)
    H = MPO(ampo, s)
    return H
end

"""
exact energy of the 1D Heisenberg Hamiltonian ground state
"""
function exactgroundenergy(J=1)
    return J * (1 / 4 - log(2))
end

"""
psi -- MPS converged on which you make the measurement 
n -- site measure

return the Sz value on the site n 
"""
function measure_Sz(psi::MPS, n)
    psi = orthogonalize(psi, n)
    sn = siteind(psi, n)
    Sz = scalar(dag(prime(psi[n], "Site")) * op("Sz", sn) * psi[n])
    return real(Sz)
end

"""
psi -- MPS converged on which you make the measurement 
n -- site measure
H -- hamiltonian

WARNING: psi and H have to be compatible that means they have to be generated by the functions in this file

return the expectation value of H on site n
"""
function measure_H(psi, n, H)
    orthogonalize!(psi, n)
    e = inner(psi, H, psi)
    return e
end

"""
s -- sites index
D -- bond dimension 

return an randmoly initialized MPS with the sites indexes in input 
"""
function random_initialized_MPS(N, D)
    s = ITensors.siteinds("S=1/2", N)
    psi = random_mps(s, linkdims=D)
    return psi, s
end

"""
return the converged mps with the row application of gates
"""
function tebdstepHeisenbergRow!(nsweep, mps, h, δτ, cutoff, Dmax)
    @showprogress for i in 1:nsweep
        gate = gateTrotterSuzukirow(mps, h, δτ)
        mps = apply(gate, mps; cutoff, maxdim=Dmax)
        normalize!(mps)
    end
    return mps
end


"""
nsweep -- number of sweeps
mps -- initial mps
gates -- even and odd you want to apply
cutoff -- cutoff in the truncation part in the applying gate process

return the converged mps with n sweeps along the mps
"""
function tebdstepHeisenberg!(nsweep, mps, h, δτ, cutoff, Dmax)
    @showprogress for i in 1:nsweep
        gateseven = gateTrotterSuzukiandhamiltonian(mps, h, δτ, "even")
        mps = apply(gateseven, mps; cutoff, maxdim=Dmax)
        normalize!(mps)
        gatesodd = gateTrotterSuzukiandhamiltonian(mps, h, δτ, "odd")
        mps = apply(gatesodd, mps; cutoff, maxdim=Dmax)
        normalize!(mps)
        gateseven = gateTrotterSuzukiandhamiltonian(mps, h, δτ, "even")
        mps = apply(gateseven, mps; cutoff, maxdim=Dmax)
        normalize!(mps)
    end
    return mps
end


"""
mps -- converged mps with tebd you want to access to the energy at the link sitemeasure
sitemeasure -- index of the site

return the energy on the site sitemeasure
"""
function energysite(mps, sitemeasure)
    copy = orthogonalize(mps, sitemeasure)
    sn = siteind(copy, sitemeasure)
    snn = siteind(copy, sitemeasure + 1)
    gate =
        -1 / 2 * op("S+", sn) * op("S-", snn) +
        -1 / 2 * op("S-", sn) * op("S+", snn)
    -h * op("Sz", sn) * op("Sz", snn)
    inter = copy[sitemeasure]*copy[sitemeasure+1]
    e = scalar(dag(prime(inter, "Site")) * gate * inter)
    return real(e)
end

